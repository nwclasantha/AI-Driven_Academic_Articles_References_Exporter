"""
Multi-Format Export System
Enterprise-level exporters for BibTeX, RIS, EndNote, JSON, and CSV
"""

import re
import json
import csv
import logging
from pathlib import Path
from typing import List, Dict, Any
from datetime import datetime
from .reference_parser import ParsedReference


class BaseExporter:
    """Base class for exporters"""

    def __init__(self):
        self.logger = logging.getLogger(__name__)

    def export(self, references: List[ParsedReference], output_path: Path) -> bool:
        """
        Export references to file

        Args:
            references: List of parsed references
            output_path: Output file path

        Returns:
            True if successful
        """
        raise NotImplementedError


class BibTeXExporter(BaseExporter):
    """
    BibTeX format exporter with validation
    """

    def export(self, references: List[ParsedReference], output_path: Path) -> bool:
        """Export to BibTeX format"""
        try:
            output_path.parent.mkdir(parents=True, exist_ok=True)

            with open(output_path, 'w', encoding='utf-8') as f:
                # Write header
                f.write(f"% Generated by IEEE Reference Extractor v3.0\n")
                f.write(f"% Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"% Total references: {len(references)}\n\n")

                # Write each reference
                for ref in references:
                    bibtex = self._to_bibtex(ref)
                    f.write(bibtex + "\n\n")

            self.logger.info(f"Exported {len(references)} references to {output_path}")
            return True
        except Exception as e:
            self.logger.error(f"BibTeX export failed: {e}")
            return False

    def _to_bibtex(self, ref: ParsedReference) -> str:
        """Convert reference to BibTeX format"""
        # Generate citation key
        key = self._generate_key(ref)

        # Determine entry type
        entry_type = ref.citation_type

        # Build BibTeX entry
        lines = [f"@{entry_type}{{{key},"]

        # Authors
        if ref.authors:
            author_str = ref.get_author_string()
            # Use double braces for single author to preserve capitalization
            if len(ref.authors) == 1:
                lines.append(f"  author    = {{{{{author_str}}}}},")
            else:
                lines.append(f"  author    = {{{author_str}}},")

        # Title
        if ref.title:
            lines.append(f"  title     = {{{ref.title}}},")

        # Journal or Booktitle
        if entry_type == 'inproceedings' and ref.booktitle:
            lines.append(f"  booktitle = {{{ref.booktitle}}},")
        elif ref.journal:
            lines.append(f"  journal   = {{{ref.journal}}},")

        # Volume
        if ref.volume:
            lines.append(f"  volume    = {{{ref.volume}}},")

        # Issue/Number
        if ref.issue:
            lines.append(f"  number    = {{{ref.issue}}},")

        # Pages
        if ref.pages:
            lines.append(f"  pages     = {{{ref.pages}}},")

        # Year
        if ref.year:
            lines.append(f"  year      = {{{ref.year}}},")

        # Publisher
        if ref.publisher:
            lines.append(f"  publisher = {{{ref.publisher}}},")

        # DOI
        if ref.doi:
            lines.append(f"  doi       = {{{ref.doi}}},")

        # URL
        if ref.url:
            lines.append(f"  url       = {{{ref.url}}},")

        # ISBN
        if ref.isbn:
            lines.append(f"  isbn      = {{{ref.isbn}}},")

        # ISSN
        if ref.issn:
            lines.append(f"  issn      = {{{ref.issn}}},")

        # Abstract (if included)
        if ref.abstract:
            # Escape special characters in abstract
            abstract = self._escape_latex(ref.abstract)
            lines.append(f"  abstract  = {{{abstract}}},")

        # Keywords
        if ref.keywords:
            keywords = ', '.join(ref.keywords)
            lines.append(f"  keywords  = {{{keywords}}},")

        # Note (confidence score)
        lines.append(f"  note      = {{Confidence: {ref.confidence:.2f}}}")

        lines.append("}")

        return "\n".join(lines)

    def _generate_key(self, ref: ParsedReference) -> str:
        """Generate BibTeX citation key"""
        # Use last author's last name + year
        if ref.authors:
            last_author = ref.authors[-1]
            # Extract last name
            parts = last_author.split()
            last_name = parts[-1] if parts else last_author
            # Clean
            last_name = re.sub(r'[^\w]', '', last_name)
        else:
            last_name = "Unknown"

        year = ref.year or "0000"

        key = f"{last_name}{year}"

        # Make unique if needed (append ref number)
        if ref.ref_number:
            key += f"_{ref.ref_number}"

        return key

    def _escape_latex(self, text: str) -> str:
        """Escape special LaTeX characters"""
        replacements = {
            '\\': r'\textbackslash{}',
            '{': r'\{',
            '}': r'\}',
            '$': r'\$',
            '%': r'\%',
            '_': r'\_',
            '#': r'\#',
            '&': r'\&',
            '~': r'\textasciitilde{}',
            '^': r'\textasciicircum{}'
        }

        for char, replacement in replacements.items():
            text = text.replace(char, replacement)

        return text


class RISExporter(BaseExporter):
    """
    RIS format exporter (Research Information Systems)
    """

    def export(self, references: List[ParsedReference], output_path: Path) -> bool:
        """Export to RIS format"""
        try:
            output_path.parent.mkdir(parents=True, exist_ok=True)

            with open(output_path, 'w', encoding='utf-8') as f:
                for ref in references:
                    ris = self._to_ris(ref)
                    f.write(ris + "\n\n")

            self.logger.info(f"Exported {len(references)} references to RIS format")
            return True
        except Exception as e:
            self.logger.error(f"RIS export failed: {e}")
            return False

    def _to_ris(self, ref: ParsedReference) -> str:
        """Convert reference to RIS format"""
        lines = []

        # Type of reference
        type_map = {
            'article': 'JOUR',
            'inproceedings': 'CONF',
            'book': 'BOOK',
            'phdthesis': 'THES',
            'techreport': 'RPRT'
        }
        ris_type = type_map.get(ref.citation_type, 'JOUR')
        lines.append(f"TY  - {ris_type}")

        # Authors
        for author in ref.authors:
            lines.append(f"AU  - {author}")

        # Title
        if ref.title:
            lines.append(f"TI  - {ref.title}")

        # Journal or Conference
        if ref.journal:
            lines.append(f"JO  - {ref.journal}")
        elif ref.booktitle:
            lines.append(f"T2  - {ref.booktitle}")

        # Year
        if ref.year:
            lines.append(f"PY  - {ref.year}")

        # Volume
        if ref.volume:
            lines.append(f"VL  - {ref.volume}")

        # Issue
        if ref.issue:
            lines.append(f"IS  - {ref.issue}")

        # Pages
        if ref.pages:
            if '-' in ref.pages:
                start, end = ref.pages.split('-', 1)
                lines.append(f"SP  - {start.strip()}")
                lines.append(f"EP  - {end.strip()}")
            else:
                lines.append(f"SP  - {ref.pages}")

        # Publisher
        if ref.publisher:
            lines.append(f"PB  - {ref.publisher}")

        # DOI
        if ref.doi:
            lines.append(f"DO  - {ref.doi}")

        # URL
        if ref.url:
            lines.append(f"UR  - {ref.url}")

        # Abstract
        if ref.abstract:
            lines.append(f"AB  - {ref.abstract}")

        # Keywords
        for keyword in ref.keywords:
            lines.append(f"KW  - {keyword}")

        # End of reference
        lines.append("ER  -")

        return "\n".join(lines)


class JSONExporter(BaseExporter):
    """JSON format exporter"""

    def export(self, references: List[ParsedReference], output_path: Path) -> bool:
        """Export to JSON format"""
        try:
            output_path.parent.mkdir(parents=True, exist_ok=True)

            data = {
                'metadata': {
                    'exported_at': datetime.now().isoformat(),
                    'version': '3.0.0',
                    'total_references': len(references)
                },
                'references': [self._to_dict(ref) for ref in references]
            }

            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)

            self.logger.info(f"Exported {len(references)} references to JSON")
            return True
        except Exception as e:
            self.logger.error(f"JSON export failed: {e}")
            return False

    def _to_dict(self, ref: ParsedReference) -> Dict[str, Any]:
        """Convert reference to dictionary"""
        return {
            'ref_number': ref.ref_number,
            'authors': ref.authors,
            'title': ref.title,
            'year': ref.year,
            'journal': ref.journal,
            'booktitle': ref.booktitle,
            'volume': ref.volume,
            'issue': ref.issue,
            'pages': ref.pages,
            'publisher': ref.publisher,
            'doi': ref.doi,
            'url': ref.url,
            'isbn': ref.isbn,
            'issn': ref.issn,
            'abstract': ref.abstract,
            'keywords': ref.keywords,
            'citation_type': ref.citation_type,
            'confidence': ref.confidence,
            'raw_text': ref.raw_text
        }


class CSVExporter(BaseExporter):
    """CSV format exporter"""

    def export(self, references: List[ParsedReference], output_path: Path) -> bool:
        """Export to CSV format"""
        try:
            output_path.parent.mkdir(parents=True, exist_ok=True)

            with open(output_path, 'w', encoding='utf-8', newline='') as f:
                writer = csv.writer(f)

                # Header
                writer.writerow([
                    'Ref#', 'Authors', 'Title', 'Year', 'Journal/Conference',
                    'Volume', 'Issue', 'Pages', 'DOI', 'URL', 'Type', 'Confidence'
                ])

                # Data
                for ref in references:
                    venue = ref.journal or ref.booktitle
                    writer.writerow([
                        ref.ref_number,
                        ref.get_author_string(),
                        ref.title,
                        ref.year,
                        venue,
                        ref.volume,
                        ref.issue,
                        ref.pages,
                        ref.doi,
                        ref.url,
                        ref.citation_type,
                        f"{ref.confidence:.2f}"
                    ])

            self.logger.info(f"Exported {len(references)} references to CSV")
            return True
        except Exception as e:
            self.logger.error(f"CSV export failed: {e}")
            return False


class ExportManager:
    """
    Manages multiple export formats
    """

    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.exporters = {
            'bibtex': BibTeXExporter(),
            'ris': RISExporter(),
            'json': JSONExporter(),
            'csv': CSVExporter()
        }

    def export(self, references: List[ParsedReference], output_path: Path,
               format: str = 'bibtex') -> bool:
        """
        Export references to specified format

        Args:
            references: List of references
            output_path: Output file path
            format: Export format (bibtex, ris, json, csv)

        Returns:
            True if successful
        """
        format = format.lower()

        if format not in self.exporters:
            self.logger.error(f"Unknown export format: {format}")
            return False

        exporter = self.exporters[format]
        return exporter.export(references, output_path)

    def export_multiple_formats(self, references: List[ParsedReference],
                                 output_dir: Path, base_name: str,
                                 formats: List[str]) -> Dict[str, bool]:
        """
        Export to multiple formats

        Args:
            references: List of references
            output_dir: Output directory
            base_name: Base filename (without extension)
            formats: List of formats to export

        Returns:
            Dictionary mapping formats to success status
        """
        output_dir.mkdir(parents=True, exist_ok=True)

        results = {}
        for fmt in formats:
            extension = self._get_extension(fmt)
            output_path = output_dir / f"{base_name}.{extension}"
            success = self.export(references, output_path, fmt)
            results[fmt] = success

        return results

    def _get_extension(self, format: str) -> str:
        """Get file extension for format"""
        extensions = {
            'bibtex': 'bib',
            'ris': 'ris',
            'json': 'json',
            'csv': 'csv'
        }
        return extensions.get(format.lower(), 'txt')

    def get_supported_formats(self) -> List[str]:
        """Get list of supported formats"""
        return list(self.exporters.keys())
